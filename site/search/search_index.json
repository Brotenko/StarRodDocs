{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started # Introduction # Star Rod is a collection of modding tools for Paper Mario 64 (US version 1.0). These tools allow modders to make sweeping changes to the game, from tweaking and rebalancing existing content to adding multiple chapters worth of new content. Paired with a basic text editor, you\u2019ll be able to add or edit maps, battles, enemies, badges, items, strings, and more. The tools contain a map editor, sprite/animation editor, image editor, and assembler. Recommended Software # Star Rod effectively dumps many game assets to text files, which you may edit and compile back to the ROM. For this reason, a large part of modding Paper Mario will involve editing text files. Context-sensitive color coding and highlighting help to read these files and prevent basic syntax errors. Use either Notepad++ or VS Code . Notepad++ user-defined language files are provided with Star Rod for script files and string files. A nice plugin for VS Code is available here (plugin courtesy of nanalan ). Sprites and textures can be edited in your favorite image editor and converted to the proper format using Star Rod\u2019s image editor. Bear in mind that all sprites and most textures use a color-indexed image format with strict limits for the number of colors per image (16 for sprites, 16 or 256 for textures). Many artists prefer using Aseprite for creating pixel art which can be exported as a color-indexed PNG or imported directly into Star Rod\u2019s sprite editor. Star Rod is written in Java and requires at least Java 1.8 (JRE 8 or newer). Creating a Mod # The first time you launch Star Rod, you will be prompted to select a valid Paper Mario US v1.0 rom and a directory for your mod. There are a variety of tools you can use to dump a backup from your own cartridge. Please ensure your cartridge matches the required version. Star Rod will perform validation before proceeding. Your mod directory will contain all the source files you\u2019ll be creating to make your Paper Mario mod. Once the new project is set up, you must first dump the rom. A folder will be created in the same directory as the ROM with all the modifiable files extracted. This process will take several minutes the first time as assets are repackaged and converted to human-readable formats. After dumping is complete, use \u201cCopy Assets to Mod\u201d to populate your mod directory with files from the dump directory. The next section will explore the directories in more detail. Once your edits are ready, use \u201cCompile Mod\u201d to produce a modded Paper Mario rom you can test out in an emulator. To ensure highest compatibility, you should use Project 64 on interpreter mode with the GLideN64 video plugin . The modded ROM will be found in $mod/out . When your mod is done and you\u2019re ready to share it with the world, use \u201cPackage Mod\u201d to create a binary diff file which users can combine with their own Paper Mario US v1.0 ROMs. Do not distribute patched ROMs. Directories # Database # Dump Directory # Mod Directory # Notation Used in this Guide #","title":"Getting Started"},{"location":"#getting-started","text":"","title":"Getting Started"},{"location":"#introduction","text":"Star Rod is a collection of modding tools for Paper Mario 64 (US version 1.0). These tools allow modders to make sweeping changes to the game, from tweaking and rebalancing existing content to adding multiple chapters worth of new content. Paired with a basic text editor, you\u2019ll be able to add or edit maps, battles, enemies, badges, items, strings, and more. The tools contain a map editor, sprite/animation editor, image editor, and assembler.","title":"Introduction"},{"location":"#recommended-software","text":"Star Rod effectively dumps many game assets to text files, which you may edit and compile back to the ROM. For this reason, a large part of modding Paper Mario will involve editing text files. Context-sensitive color coding and highlighting help to read these files and prevent basic syntax errors. Use either Notepad++ or VS Code . Notepad++ user-defined language files are provided with Star Rod for script files and string files. A nice plugin for VS Code is available here (plugin courtesy of nanalan ). Sprites and textures can be edited in your favorite image editor and converted to the proper format using Star Rod\u2019s image editor. Bear in mind that all sprites and most textures use a color-indexed image format with strict limits for the number of colors per image (16 for sprites, 16 or 256 for textures). Many artists prefer using Aseprite for creating pixel art which can be exported as a color-indexed PNG or imported directly into Star Rod\u2019s sprite editor. Star Rod is written in Java and requires at least Java 1.8 (JRE 8 or newer).","title":"Recommended Software"},{"location":"#creating-a-mod","text":"The first time you launch Star Rod, you will be prompted to select a valid Paper Mario US v1.0 rom and a directory for your mod. There are a variety of tools you can use to dump a backup from your own cartridge. Please ensure your cartridge matches the required version. Star Rod will perform validation before proceeding. Your mod directory will contain all the source files you\u2019ll be creating to make your Paper Mario mod. Once the new project is set up, you must first dump the rom. A folder will be created in the same directory as the ROM with all the modifiable files extracted. This process will take several minutes the first time as assets are repackaged and converted to human-readable formats. After dumping is complete, use \u201cCopy Assets to Mod\u201d to populate your mod directory with files from the dump directory. The next section will explore the directories in more detail. Once your edits are ready, use \u201cCompile Mod\u201d to produce a modded Paper Mario rom you can test out in an emulator. To ensure highest compatibility, you should use Project 64 on interpreter mode with the GLideN64 video plugin . The modded ROM will be found in $mod/out . When your mod is done and you\u2019re ready to share it with the world, use \u201cPackage Mod\u201d to create a binary diff file which users can combine with their own Paper Mario US v1.0 ROMs. Do not distribute patched ROMs.","title":"Creating a Mod"},{"location":"#directories","text":"","title":"Directories"},{"location":"#database","text":"","title":"Database"},{"location":"#dump-directory","text":"","title":"Dump Directory"},{"location":"#mod-directory","text":"","title":"Mod Directory"},{"location":"#notation-used-in-this-guide","text":"","title":"Notation Used in this Guide"},{"location":"battles/","text":"","title":"Battles"},{"location":"command-line-interface/","text":"","title":"Command Line Interface"},{"location":"editing-items/","text":"Editing Items # Adding a New","title":"Editing Items"},{"location":"editing-items/#editing-items","text":"Adding a New","title":"Editing Items"},{"location":"editing-sprites/","text":"Editing Sprites # Adding a new NPC sprite # To add a new NPC sprite, duplicate one of the folders in $MOD/sprite/npc/src/, give it a new name, and add the new sprite to $MOD/sprite/SpriteTable.xml. The new sprite will now appear in the sprite editor and will be built when you compile your mod. Palettes # Sprites only used in the world may have whatever palettes you like, but sprites which are used in battle are expected to have a certain number of palettes in a particular order to properly display status ailments. The expected order is: Partner Actors: x Status Description 0 Normal Unchanged 1 Poisoned Green tint 2 Turn Finished Darker tint 3 Shocked Yellow tint 4 Burned Blackened Enemy Actor: x Status Description 0 Normal Unchanged 1 Poisoned Green tint 2 Turn Finished Darker tint 3 Shocked Yellow tint 4 Burned Blackened Enemies with different color-variants (palette-swaps) have a separate set of palettes for each color variant (see sprite 31). In the sprite editor, the number of color variants is controlled by the \u201cGroups\u201d field of the \u201cSpritesheet\u201d tab. The palettes are expected in the following order: Normal 1, Normal 2, \u2026, Normal N Poisoned 1, Poisoned 2, \u2026, Poisoned N Dizzy 1, Dizzy 2, \u2026, Dizzy N Shocked 1, Shocked 2, \u2026 Shocked N Burned (only one) Additional palettes for certain \u201caccessories\u201d appear after these (see sprite 68).","title":"Editing Sprites"},{"location":"editing-sprites/#editing-sprites","text":"","title":"Editing Sprites"},{"location":"editing-sprites/#adding-a-new-npc-sprite","text":"To add a new NPC sprite, duplicate one of the folders in $MOD/sprite/npc/src/, give it a new name, and add the new sprite to $MOD/sprite/SpriteTable.xml. The new sprite will now appear in the sprite editor and will be built when you compile your mod.","title":"Adding a new NPC sprite"},{"location":"editing-sprites/#palettes","text":"Sprites only used in the world may have whatever palettes you like, but sprites which are used in battle are expected to have a certain number of palettes in a particular order to properly display status ailments. The expected order is: Partner Actors: x Status Description 0 Normal Unchanged 1 Poisoned Green tint 2 Turn Finished Darker tint 3 Shocked Yellow tint 4 Burned Blackened Enemy Actor: x Status Description 0 Normal Unchanged 1 Poisoned Green tint 2 Turn Finished Darker tint 3 Shocked Yellow tint 4 Burned Blackened Enemies with different color-variants (palette-swaps) have a separate set of palettes for each color variant (see sprite 31). In the sprite editor, the number of color variants is controlled by the \u201cGroups\u201d field of the \u201cSpritesheet\u201d tab. The palettes are expected in the following order: Normal 1, Normal 2, \u2026, Normal N Poisoned 1, Poisoned 2, \u2026, Poisoned N Dizzy 1, Dizzy 2, \u2026, Dizzy N Shocked 1, Shocked 2, \u2026 Shocked N Burned (only one) Additional palettes for certain \u201caccessories\u201d appear after these (see sprite 68).","title":"Palettes"},{"location":"engine-limits/","text":"","title":"Engine Limits"},{"location":"globals/","text":"Globals # Enums # Database # Mod Globals #","title":"Globals"},{"location":"globals/#globals","text":"","title":"Globals"},{"location":"globals/#enums","text":"","title":"Enums"},{"location":"globals/#database","text":"","title":"Database"},{"location":"globals/#mod-globals","text":"","title":"Mod Globals"},{"location":"icons/","text":"Icons # There are two icon varieties used in different situations. Item icons share their ID with entries in the item table and are responsible for the appearance of items in the game world. Menu icons govern the appearance of items in the pause screen and elsewhere in the UI. Their IDs are assigned to various items in the item table. Both types of icons reference the same pool of images. Editing existing icons # Icon textures can be altered by simply editing the images in $MOD/image/icon/image . Be careful not to change their size. Remember that icons in pairs need both images to be updated, with the second being a desaturated version of the first (same image, different palette). More sophisticated edits are possible through editing their animation files. You will almost never want to do this, so I leave it as an exercise to the reader. Adding new icons # Strictly speaking, you cannot add new menu or item icons.","title":"Icons"},{"location":"icons/#icons","text":"There are two icon varieties used in different situations. Item icons share their ID with entries in the item table and are responsible for the appearance of items in the game world. Menu icons govern the appearance of items in the pause screen and elsewhere in the UI. Their IDs are assigned to various items in the item table. Both types of icons reference the same pool of images.","title":"Icons"},{"location":"icons/#editing-existing-icons","text":"Icon textures can be altered by simply editing the images in $MOD/image/icon/image . Be careful not to change their size. Remember that icons in pairs need both images to be updated, with the second being a desaturated version of the first (same image, different palette). More sophisticated edits are possible through editing their animation files. You will almost never want to do this, so I leave it as an exercise to the reader.","title":"Editing existing icons"},{"location":"icons/#adding-new-icons","text":"Strictly speaking, you cannot add new menu or item icons.","title":"Adding new icons"},{"location":"maps/","text":"","title":"Maps"},{"location":"the-debug-menu/","text":"","title":"The Debug Menug"},{"location":"using-strings/","text":"Using Strings # String Theory # Messages in Paper Mario use a special string format which Star Rod translates into a custom markup language. Non-printing characters are represented by tags enclosed by square brackets with colon-separated parameters. Tags are used for special characters, such as symbols and button icons like [C-LEFT]; pauses or delays in printing like [PAUSE]; and more complex formatting functions which modify text size/color/etc, e.g. [Size:0A:0A] , or show graphics like Icons and Images. Each string has a unique identifier which includes a 16-bit section ID and a 16-bit message ID. For example, string 001C0002 is message 2 in section 1C. Check the /strings/ folder of your ROM dump for numerous examples. When you compile your mod, Star Rod converts these back into the native Paper Mario string format. Star Rod String Markup Guide # Special Characters # Button Icons [A] [B] [L] [R] [Z] [C-UP] [C-DOWN] [C-LEFT] [C-RIGHT] [START] Solid Arrows [UP] [DOWN] [LEFT] [RIGHT] Misc Shapes [NOTE] [HEART] [STAR] [CIRCLE] [CROSS] Characters for %, [], and {} can be written with an escape character \\%, [, ], {, and }. Formatting Tags # Tag Description [END] Terminates the string. All valid strings must end with this tag. [...] Causes the parser to combine the current line with the next one. [WAIT] Waits for the player to press A. [NEXT] Scrolls the message box down to the next set of text. [STYLE:type] Sets the style of the message box. Found at the beginning of most strings. Message Box Styles # Style Description RIGHT Standard NPC speech bubble connected to the speaker from the right side. LEFT Standard NPC speech bubble connected to the speaker from the left side. CENTER Standard NPC speech bubble connected to the speaker from the center. TATTLE Adaptive-size NPC speech bubble designed for Goombario's map tattles. CHOICE Expects args: 4 (width, pos x, height, pos y) INSPECT Grey with a scrolling background pattern. Used when inspecting things. SIGN Text box looks like a wooden sign. LAMPPOST Metallic sign used for the lamp post in Toad Town. args: height of text box POPUP Creates a two-line text box in the middle of the screen with an automatic width. Used in scripts only for the \u201cYou got Kooper's shell!\u201d message. POSTCARD Similar to INSPECT. Displays a postcard image on the bottom half of the screen. args: postcard index UPGRADE Used for upgrade blocks. Silent. Grey transparent scrolling BG, rounded frame. args: 4 (width, pos x, height, pos y) NARRATE \"you got X!\", \"Y joined your party!\" EPILOGUE Used on the End of Chapter screens. Silent and centered with no background. Functions # TODO Effect Types # Effect Description Rainbow Text colors change in a rainbow pattern. RainbowB Same (?) as Rainbow. DropShadow Adds a drop shadow effect to text. Faded Text is partially transparent. args: opacity (00 = invisible, FF = opaque) Jitter Causes the characters to move around randomly. It looks like the speaker is cold or frightened. FadedJitter Partially transparent version of Jitter. args: opacity (00 = invisible, FF = opaque) Noise A noise pattern is overlaid over the text. FadedNoise Partially transparent Noise overlaid on text. args: noise opacity (00 = invisible, FF = opaque) Wavy Characters move in little circles, creating an overall sine wave effect. WavyB Same (?) as Wavy. SizeJitter Character sizes fluctuate randomly. SizeWave Characters move in and out, creating a wave effect of changing size. Shrinking Large characters are printed that quickly shrink to normal size. Growing Small characters are printed that quickly grow to normal size. Modifying/Adding Messages # Any existing string can be modified or overwritten using text files in $mod/strings/ . New ones can be added to any section, including a new section (2F) for custom strings. To illustrate, let's modify an existing string: 001C0002 (the tattle for Paragoomba). Create a text file $mod/strings/example.str (any filename will do) and insert the following: #string:1C:02 { [STYLE:RIGHT][...] Paragoomba tattle! [WAIT][END] } The first line is the string ID with section and message IDs separated by colons. Then the string begins. All valid strings must be terminated by an [END] tag. You can add new strings with whatever ID you like, so long as the section ID is valid. If you don't care what ID the string gets, or prefer not to use hardcoded string IDs, you can give them a name instead. This name can be used in script files and will automatically be replaced by the proper string ID when you compile your mod. The following example is referenced in script files with {String:MyStringName} : #string:1C:(MyStringName) { [STYLE:RIGHT][...] Paragoomba tattle! [WAIT][END] } Another way to use custom strings is to simply embed them in script files. This is great for strings that you don't plan to reuse, or which are not displayed in menus. Here's an example from a script file: #string $MyExampleString { [STYLE:RIGHT][...] This is an example string. [WAIT][END] } Examples # String with Variables # Strings may contain variables to create messages like \u201cYou won X coins!\u201d or \u201cDo you want to cook with Y?\u201d . Up to four variables can be set, denoted by [Var:0] through [Var:3], which are substituted when the message is displayed. Use these functions to set them in scripts before displaying the message: Integer values: Call SetMessageValue ( value, variable index ) String values: Call SetMessageString ( string, variable index ) String variables are usually set with pointers to the string. For example, you can use 8014C294 and 8014C290 to conditionally add \u201cs\u201d to the end of words if they are plural. Presenting a Choice # A proper choice dialog has three strings: the question, the options, and the response. Questions should be asked with SayMessage0() and end with {Func_04}, for example: [STYLE:RIGHT] Are you ready for a trial?[BR] [Func_04][END] Options must use the following format. The SetCancel call is optional. Choices can contain up to five options. If you need more, use a nested dialog tree. [STYLE:CHOICE:60:70:80:3E][DelayOff][...] [Cursor:00][Option:00]Yes [Cursor:01][Option:01]No [Cursor:02][Option:02]Tell me more[...] [Option:FF][DelayOn][SetCancel:01}[...] [EndChoice:03][END] Responses should be shown with SayMessage2() and begin with [NEXT] rather than [STYLE]. [NEXT]All right, maybe next time.[WAIT][END] TIP: When setting up choice dialog boxes, you may have trouble deciding how big to make them and where to place them on the screen. When displayed, their size/position is stored at the following memory addresses, where you can edit them for a live preview: 801555E2 hpos (0 = left) 801555E4 vpos (0 = top) 8015569C hsize 8015569E vsize To center the box, set hpos = 160` - hsize/2. Displaying an Image # Strings can display arbitrary images using the Image1 and Image7 functions. Both operate in the same manner, the latter just requires you to specify all the properties (position, etc) of the image in one function, rather than using several functions in conjunction to format it. The images may either be embedded in the map (see mgm_01) or loaded from the asset table (see osr_00 or any map where you get a new partner). In either case, you must tell the message system which image you want to use with set_message_images before displaying the message. The argument to this function is a pointer to an \u201cimage table\u201d, which you must set up. Here is an example: #new:Function $SetImageList { PUSH RA LIA A0, $ImageList JAL 80125B2C NOP POP RA JR RA ADDIU V0, R0, 2 } #new:IntTable $ImageList { $Image0_Raster $Image0_Palette 00200020 00000002 00000000 $Image1_Raster $Image1_Palette 00200020 00000002 00000000 } % ~RasterFile etc refer to files in `$mod/res/` #new:IntTable $Image0_Raster { ~RasterFile:CI-4:example0.png } #new:IntTable $Image0_Palette { ~PaletteFile:CI-4:example0.png } #new:IntTable $Image1_Raster { ~RasterFile:CI-4:example1.png } #new:IntTable $Image1_Palette { ~PaletteFile:CI-4:example1.png } #new:Script $Conversation { ... Call $SetImageList ( ) Call SayMessage0 ( ... $ShowImageString ) ... } #string $ShowImageString { [Image7:00:00:55:61:01:FF:0F][Func_04][END] }","title":"Using Strings"},{"location":"using-strings/#using-strings","text":"","title":"Using Strings"},{"location":"using-strings/#string-theory","text":"Messages in Paper Mario use a special string format which Star Rod translates into a custom markup language. Non-printing characters are represented by tags enclosed by square brackets with colon-separated parameters. Tags are used for special characters, such as symbols and button icons like [C-LEFT]; pauses or delays in printing like [PAUSE]; and more complex formatting functions which modify text size/color/etc, e.g. [Size:0A:0A] , or show graphics like Icons and Images. Each string has a unique identifier which includes a 16-bit section ID and a 16-bit message ID. For example, string 001C0002 is message 2 in section 1C. Check the /strings/ folder of your ROM dump for numerous examples. When you compile your mod, Star Rod converts these back into the native Paper Mario string format.","title":"String Theory"},{"location":"using-strings/#star-rod-string-markup-guide","text":"","title":"Star Rod String Markup Guide"},{"location":"using-strings/#special-characters","text":"Button Icons [A] [B] [L] [R] [Z] [C-UP] [C-DOWN] [C-LEFT] [C-RIGHT] [START] Solid Arrows [UP] [DOWN] [LEFT] [RIGHT] Misc Shapes [NOTE] [HEART] [STAR] [CIRCLE] [CROSS] Characters for %, [], and {} can be written with an escape character \\%, [, ], {, and }.","title":"Special Characters"},{"location":"using-strings/#formatting-tags","text":"Tag Description [END] Terminates the string. All valid strings must end with this tag. [...] Causes the parser to combine the current line with the next one. [WAIT] Waits for the player to press A. [NEXT] Scrolls the message box down to the next set of text. [STYLE:type] Sets the style of the message box. Found at the beginning of most strings.","title":"Formatting Tags"},{"location":"using-strings/#message-box-styles","text":"Style Description RIGHT Standard NPC speech bubble connected to the speaker from the right side. LEFT Standard NPC speech bubble connected to the speaker from the left side. CENTER Standard NPC speech bubble connected to the speaker from the center. TATTLE Adaptive-size NPC speech bubble designed for Goombario's map tattles. CHOICE Expects args: 4 (width, pos x, height, pos y) INSPECT Grey with a scrolling background pattern. Used when inspecting things. SIGN Text box looks like a wooden sign. LAMPPOST Metallic sign used for the lamp post in Toad Town. args: height of text box POPUP Creates a two-line text box in the middle of the screen with an automatic width. Used in scripts only for the \u201cYou got Kooper's shell!\u201d message. POSTCARD Similar to INSPECT. Displays a postcard image on the bottom half of the screen. args: postcard index UPGRADE Used for upgrade blocks. Silent. Grey transparent scrolling BG, rounded frame. args: 4 (width, pos x, height, pos y) NARRATE \"you got X!\", \"Y joined your party!\" EPILOGUE Used on the End of Chapter screens. Silent and centered with no background.","title":"Message Box Styles"},{"location":"using-strings/#functions","text":"TODO","title":"Functions"},{"location":"using-strings/#effect-types","text":"Effect Description Rainbow Text colors change in a rainbow pattern. RainbowB Same (?) as Rainbow. DropShadow Adds a drop shadow effect to text. Faded Text is partially transparent. args: opacity (00 = invisible, FF = opaque) Jitter Causes the characters to move around randomly. It looks like the speaker is cold or frightened. FadedJitter Partially transparent version of Jitter. args: opacity (00 = invisible, FF = opaque) Noise A noise pattern is overlaid over the text. FadedNoise Partially transparent Noise overlaid on text. args: noise opacity (00 = invisible, FF = opaque) Wavy Characters move in little circles, creating an overall sine wave effect. WavyB Same (?) as Wavy. SizeJitter Character sizes fluctuate randomly. SizeWave Characters move in and out, creating a wave effect of changing size. Shrinking Large characters are printed that quickly shrink to normal size. Growing Small characters are printed that quickly grow to normal size.","title":"Effect Types"},{"location":"using-strings/#modifyingadding-messages","text":"Any existing string can be modified or overwritten using text files in $mod/strings/ . New ones can be added to any section, including a new section (2F) for custom strings. To illustrate, let's modify an existing string: 001C0002 (the tattle for Paragoomba). Create a text file $mod/strings/example.str (any filename will do) and insert the following: #string:1C:02 { [STYLE:RIGHT][...] Paragoomba tattle! [WAIT][END] } The first line is the string ID with section and message IDs separated by colons. Then the string begins. All valid strings must be terminated by an [END] tag. You can add new strings with whatever ID you like, so long as the section ID is valid. If you don't care what ID the string gets, or prefer not to use hardcoded string IDs, you can give them a name instead. This name can be used in script files and will automatically be replaced by the proper string ID when you compile your mod. The following example is referenced in script files with {String:MyStringName} : #string:1C:(MyStringName) { [STYLE:RIGHT][...] Paragoomba tattle! [WAIT][END] } Another way to use custom strings is to simply embed them in script files. This is great for strings that you don't plan to reuse, or which are not displayed in menus. Here's an example from a script file: #string $MyExampleString { [STYLE:RIGHT][...] This is an example string. [WAIT][END] }","title":"Modifying/Adding Messages"},{"location":"using-strings/#examples","text":"","title":"Examples"},{"location":"using-strings/#string-with-variables","text":"Strings may contain variables to create messages like \u201cYou won X coins!\u201d or \u201cDo you want to cook with Y?\u201d . Up to four variables can be set, denoted by [Var:0] through [Var:3], which are substituted when the message is displayed. Use these functions to set them in scripts before displaying the message: Integer values: Call SetMessageValue ( value, variable index ) String values: Call SetMessageString ( string, variable index ) String variables are usually set with pointers to the string. For example, you can use 8014C294 and 8014C290 to conditionally add \u201cs\u201d to the end of words if they are plural.","title":"String with Variables"},{"location":"using-strings/#presenting-a-choice","text":"A proper choice dialog has three strings: the question, the options, and the response. Questions should be asked with SayMessage0() and end with {Func_04}, for example: [STYLE:RIGHT] Are you ready for a trial?[BR] [Func_04][END] Options must use the following format. The SetCancel call is optional. Choices can contain up to five options. If you need more, use a nested dialog tree. [STYLE:CHOICE:60:70:80:3E][DelayOff][...] [Cursor:00][Option:00]Yes [Cursor:01][Option:01]No [Cursor:02][Option:02]Tell me more[...] [Option:FF][DelayOn][SetCancel:01}[...] [EndChoice:03][END] Responses should be shown with SayMessage2() and begin with [NEXT] rather than [STYLE]. [NEXT]All right, maybe next time.[WAIT][END] TIP: When setting up choice dialog boxes, you may have trouble deciding how big to make them and where to place them on the screen. When displayed, their size/position is stored at the following memory addresses, where you can edit them for a live preview: 801555E2 hpos (0 = left) 801555E4 vpos (0 = top) 8015569C hsize 8015569E vsize To center the box, set hpos = 160` - hsize/2.","title":"Presenting a Choice"},{"location":"using-strings/#displaying-an-image","text":"Strings can display arbitrary images using the Image1 and Image7 functions. Both operate in the same manner, the latter just requires you to specify all the properties (position, etc) of the image in one function, rather than using several functions in conjunction to format it. The images may either be embedded in the map (see mgm_01) or loaded from the asset table (see osr_00 or any map where you get a new partner). In either case, you must tell the message system which image you want to use with set_message_images before displaying the message. The argument to this function is a pointer to an \u201cimage table\u201d, which you must set up. Here is an example: #new:Function $SetImageList { PUSH RA LIA A0, $ImageList JAL 80125B2C NOP POP RA JR RA ADDIU V0, R0, 2 } #new:IntTable $ImageList { $Image0_Raster $Image0_Palette 00200020 00000002 00000000 $Image1_Raster $Image1_Palette 00200020 00000002 00000000 } % ~RasterFile etc refer to files in `$mod/res/` #new:IntTable $Image0_Raster { ~RasterFile:CI-4:example0.png } #new:IntTable $Image0_Palette { ~PaletteFile:CI-4:example0.png } #new:IntTable $Image1_Raster { ~RasterFile:CI-4:example1.png } #new:IntTable $Image1_Palette { ~PaletteFile:CI-4:example1.png } #new:Script $Conversation { ... Call $SetImageList ( ) Call SayMessage0 ( ... $ShowImageString ) ... } #string $ShowImageString { [Image7:00:00:55:61:01:FF:0F][Func_04][END] }","title":"Displaying an Image"},{"location":"writing-code/","text":"Writing Code # Assembly # The N64 uses the NEC VR4300 CPU, closely related to the MIPS R4300i. As such, the compiled machine code in Paper Mario can be disassembled into MIPS assembly language. Star Rod uses a custom MIPS assembler/disassembler to convert between machine code on the ROM and a (more) user-friendly assembly language. As functions are dumped from the ROM, branches and jump tables are recognized and appropriate labels are created for their destinations. You can use labels as branch targets in your own code. You can also reference pointers (e.g. $Script_Example ), script variables (e.g. *StoryProgress ), and special functions (e.g. {Func:GetVariable} ). Note: Register 30 may be referenced as either S8 or FP. Both are accepted. Pseudo-Instructions # During the dump, certain sequences of instructions are replaced by pseudo-instructions (PIs) to help find pointers and data structures that would otherwise be 'hidden' within functions. In this way, relocated data structures can have their pointers properly updated. You are encouraged to use these pseudo-instructions in your own code to improve readability and reduce errors. Note: Don't worry about the distinction between LIA and LIO. For reversibility only. Convenience # Command Description CLEAR X Set X = 0. Equivalent to DADDU X, R0, R0 COPY X, Y Set X = Y. Equivalent to DADDU X, Y, R0 SUBI X, Y, 1234 Subtracts an immediate value. SUBIU X, Y, 1234 Subtracts an immediate value (unsigned). LIA X, 12345678 Load a constant word to register (ADD variant). LIO X, 12345678 Load a constant word to register (OR variant). LIF FX, 3.25 Load a constant float to COP1 register. Load/Store Address # Command Description LAB X, ADDR Load a byte from ADDR to register. LABU X, ADDR Load an unsigned byte from ADDR to register. SAB X, ADDR Store a byte from register to ADDR. LAH X, ADDR Load a half-word from ADDR to register. LAHU X, ADDR Load an unsigned half-word from ADDR to register. SAH X, ADDR Store a half-word from register to ADDR. LAW X, ADDR Load a word from ADDR to register. SAW X, ADDR Store a word from register to ADDR. LAF FX, ADDR Load a float from ADDR to COP1 register. SAF FX, ADDR Store a float from COP1 register to ADDR. LAD FX, ADDR Load a double float from ADDR to COP1 register. Load/Store Table # Command Description LTB X, Y (ADDR) Load the Yth byte from ADDR to X. LTBU X, Y (ADDR) Load the Yth unsigned byte from ADDR to X. LTH X, Y (ADDR) Load the Yth half-word from ADDR to X. LTHU X, Y (ADDR) Load the Yth unsigned half-word from ADDR to X. LTW X, Y (ADDR) Load the Yth word from ADDR to X. LTF FX, Y (ADDR) Load the Yth float from ADDR to COP1 register FX. STB X, Y (ADDR) Store X at the Yth byte from ADDR. STH X, Y (ADDR) Store X at the Yth half-word from ADDR. STW X, Y (ADDR) Store X at the Yth word from ADDR. STF FX, Y (ADDR) Store X at the Yth float from ADDR. Stack Operations # Standard MIPS calling conventions require functions to preserve the values of certain registers when they are called. These values are saved to the stack at the beginning of the function and restored at the end. To minimize the opportunity for errors, Star Rod introduces several simple pseudo-instructions for these stack operations: PUSH, POP, and JPOP (identical to POP + JR RA + NOP). You can use these with multiple registers, but be sure to list the same registers in the same order for both. Command Description PUSH X, Y, ... Push a list of registers onto the stack, starting at SP[10]. Updates the stack pointer accordingly, padded to 8-byte alignment as needed. POP X, Y, ... Restores registers from the stack. Order is important! Use the same list as the corresponding push. Updates the stack pointer. JPOP X, Y, ... Identical to POP followed by JR RA. Stack addition is done in the delay slot of the JR, so this does not need to be followed by a NOP. Branch Conditions # Command Description BLT X, Y Branch if X < Y. BGT X, Y Branch if X > Y. BLE X, Y Branch if X <= Y. BGE X, Y Branch if X >= Y. BLTL/BGTL/BLEL/BGEL Branch \u201clikely\u201d variants. Special # Command Description RESERVED Put this in a delay slot following a PI and a jump to force the final instruction of the compiled PI to occupy the delay slot. Loops # Loops can be created using the LOOP and ENDLOOP pseudo-instruction. Instructions between them become the body of the loop. Labels and branching logic are created automatically and only a single register is required for the loop index value. You may also exit the loop at any time from within its body with the BREAKLOOP pseudo-instruction. For-Loops # LOOP index = start,step,end ... ENDLOOP This loop will initialize the value of a register (index) to start and increment it by step at the end of each iteration until it equals or exceeds end . The condition is also checked before the first iteration. index can be any register, the other three can be any register or any 16-bit immediate integer value. Setting step to a negative value creates a decrementing loop. Omitting step defaults to a value of +1. If a register is used for step or end , you should avoid modifying their values in the loop body. For loop examples: LOOP A0 = 0,5 Executes body with A0 = 0,1,2,3,4 LOOP T1 = 1,2,10 Executes body with T1 = 1,3,5,7,9 LOOP SP = SP,4,T4 Executes body, incrementing SP by 4 until it equals or exceeds T4. While-Loops # LOOP index < value ... ENDLOOP This loop will execute the body so long as the condition is true. The condition is checked prior to each iteration. index may be any register and value may be a register or a 16-bit immediate value. There are six valid options for the comparison test: >, >=, <, <=, ==, != While loop examples: LOOP A0 < 10` LOOP T0 != T1 LOOP S4 > 0 Register Naming # Registers can be assigned names with #DEF and reverted to their default names with #UNDEF . For example: #DEF A0, *Counter CLEAR *Counter ADDIU *Counter, *Counter, 1 ADDIU *Counter, *Counter, 1 #UNDEF A0 COPY A1, A0 In this example, A0 may only be referred to as *Counter until the name is cleared by #UNDEF . Examples # Check if a badge is equipped # % in: A0 = badge ID to check for % out: V0 = 1 if badge equipped, 0 if not #DEF A0, *BadgeID PUSH S0, S1 % Push saved registers to stack LIO S0, 8010F498 % Initialize loop start ADDIU S1, S0, 80 % 0x40 badge slots LOOP S0 = S0:2:S1 LHU V1, 0 (S0) BEQL V1, *BadgeID, .Done ADDIU V0, R0, 1 % Return TRUE ENDLOOP CLEAR V0 % Return FALSE .Done JPOP S0, S1 % Pop saved registers from stack Writing a Script-Callable Function # Functions intended to be called by scripts using the Call command must follow certain rules to operate correctly. Your function must return a value from the eCommandResult enum (detailed below). Most functions will return eScriptContinue , indicating the script should resume execution after the function is complete. Return 0 instead if you\u2019d like to block the script and have it call your function every frame until some task is finished or condition is met. You may use the int[4] array at (script_context + 0x70) to store temporary values between repeated calls if you don\u2019t want to modify the script variables. Valid return values: FF eScriptYield Script will stop executing (until next frame) <0 ??? script returns 1 0 eScriptBlock Script will not proceed any further this frame 1 ??? script returns 0 2 eScriptContinue 3 eScriptRepeat Arguments: A0 pointer to the script_context data structure of the caller A1 isInitialCall boolean, true on the first call, false on subsequent ones A2 address of the callee function S0 pointer to the function argument list in the script S1 duplicate of A0","title":"Writing Code"},{"location":"writing-code/#writing-code","text":"","title":"Writing Code"},{"location":"writing-code/#assembly","text":"The N64 uses the NEC VR4300 CPU, closely related to the MIPS R4300i. As such, the compiled machine code in Paper Mario can be disassembled into MIPS assembly language. Star Rod uses a custom MIPS assembler/disassembler to convert between machine code on the ROM and a (more) user-friendly assembly language. As functions are dumped from the ROM, branches and jump tables are recognized and appropriate labels are created for their destinations. You can use labels as branch targets in your own code. You can also reference pointers (e.g. $Script_Example ), script variables (e.g. *StoryProgress ), and special functions (e.g. {Func:GetVariable} ). Note: Register 30 may be referenced as either S8 or FP. Both are accepted.","title":"Assembly"},{"location":"writing-code/#pseudo-instructions","text":"During the dump, certain sequences of instructions are replaced by pseudo-instructions (PIs) to help find pointers and data structures that would otherwise be 'hidden' within functions. In this way, relocated data structures can have their pointers properly updated. You are encouraged to use these pseudo-instructions in your own code to improve readability and reduce errors. Note: Don't worry about the distinction between LIA and LIO. For reversibility only.","title":"Pseudo-Instructions"},{"location":"writing-code/#convenience","text":"Command Description CLEAR X Set X = 0. Equivalent to DADDU X, R0, R0 COPY X, Y Set X = Y. Equivalent to DADDU X, Y, R0 SUBI X, Y, 1234 Subtracts an immediate value. SUBIU X, Y, 1234 Subtracts an immediate value (unsigned). LIA X, 12345678 Load a constant word to register (ADD variant). LIO X, 12345678 Load a constant word to register (OR variant). LIF FX, 3.25 Load a constant float to COP1 register.","title":"Convenience"},{"location":"writing-code/#loadstore-address","text":"Command Description LAB X, ADDR Load a byte from ADDR to register. LABU X, ADDR Load an unsigned byte from ADDR to register. SAB X, ADDR Store a byte from register to ADDR. LAH X, ADDR Load a half-word from ADDR to register. LAHU X, ADDR Load an unsigned half-word from ADDR to register. SAH X, ADDR Store a half-word from register to ADDR. LAW X, ADDR Load a word from ADDR to register. SAW X, ADDR Store a word from register to ADDR. LAF FX, ADDR Load a float from ADDR to COP1 register. SAF FX, ADDR Store a float from COP1 register to ADDR. LAD FX, ADDR Load a double float from ADDR to COP1 register.","title":"Load/Store Address"},{"location":"writing-code/#loadstore-table","text":"Command Description LTB X, Y (ADDR) Load the Yth byte from ADDR to X. LTBU X, Y (ADDR) Load the Yth unsigned byte from ADDR to X. LTH X, Y (ADDR) Load the Yth half-word from ADDR to X. LTHU X, Y (ADDR) Load the Yth unsigned half-word from ADDR to X. LTW X, Y (ADDR) Load the Yth word from ADDR to X. LTF FX, Y (ADDR) Load the Yth float from ADDR to COP1 register FX. STB X, Y (ADDR) Store X at the Yth byte from ADDR. STH X, Y (ADDR) Store X at the Yth half-word from ADDR. STW X, Y (ADDR) Store X at the Yth word from ADDR. STF FX, Y (ADDR) Store X at the Yth float from ADDR.","title":"Load/Store Table"},{"location":"writing-code/#stack-operations","text":"Standard MIPS calling conventions require functions to preserve the values of certain registers when they are called. These values are saved to the stack at the beginning of the function and restored at the end. To minimize the opportunity for errors, Star Rod introduces several simple pseudo-instructions for these stack operations: PUSH, POP, and JPOP (identical to POP + JR RA + NOP). You can use these with multiple registers, but be sure to list the same registers in the same order for both. Command Description PUSH X, Y, ... Push a list of registers onto the stack, starting at SP[10]. Updates the stack pointer accordingly, padded to 8-byte alignment as needed. POP X, Y, ... Restores registers from the stack. Order is important! Use the same list as the corresponding push. Updates the stack pointer. JPOP X, Y, ... Identical to POP followed by JR RA. Stack addition is done in the delay slot of the JR, so this does not need to be followed by a NOP.","title":"Stack Operations"},{"location":"writing-code/#branch-conditions","text":"Command Description BLT X, Y Branch if X < Y. BGT X, Y Branch if X > Y. BLE X, Y Branch if X <= Y. BGE X, Y Branch if X >= Y. BLTL/BGTL/BLEL/BGEL Branch \u201clikely\u201d variants.","title":"Branch Conditions"},{"location":"writing-code/#special","text":"Command Description RESERVED Put this in a delay slot following a PI and a jump to force the final instruction of the compiled PI to occupy the delay slot.","title":"Special"},{"location":"writing-code/#loops","text":"Loops can be created using the LOOP and ENDLOOP pseudo-instruction. Instructions between them become the body of the loop. Labels and branching logic are created automatically and only a single register is required for the loop index value. You may also exit the loop at any time from within its body with the BREAKLOOP pseudo-instruction.","title":"Loops"},{"location":"writing-code/#for-loops","text":"LOOP index = start,step,end ... ENDLOOP This loop will initialize the value of a register (index) to start and increment it by step at the end of each iteration until it equals or exceeds end . The condition is also checked before the first iteration. index can be any register, the other three can be any register or any 16-bit immediate integer value. Setting step to a negative value creates a decrementing loop. Omitting step defaults to a value of +1. If a register is used for step or end , you should avoid modifying their values in the loop body. For loop examples: LOOP A0 = 0,5 Executes body with A0 = 0,1,2,3,4 LOOP T1 = 1,2,10 Executes body with T1 = 1,3,5,7,9 LOOP SP = SP,4,T4 Executes body, incrementing SP by 4 until it equals or exceeds T4.","title":"For-Loops"},{"location":"writing-code/#while-loops","text":"LOOP index < value ... ENDLOOP This loop will execute the body so long as the condition is true. The condition is checked prior to each iteration. index may be any register and value may be a register or a 16-bit immediate value. There are six valid options for the comparison test: >, >=, <, <=, ==, != While loop examples: LOOP A0 < 10` LOOP T0 != T1 LOOP S4 > 0","title":"While-Loops"},{"location":"writing-code/#register-naming","text":"Registers can be assigned names with #DEF and reverted to their default names with #UNDEF . For example: #DEF A0, *Counter CLEAR *Counter ADDIU *Counter, *Counter, 1 ADDIU *Counter, *Counter, 1 #UNDEF A0 COPY A1, A0 In this example, A0 may only be referred to as *Counter until the name is cleared by #UNDEF .","title":"Register Naming"},{"location":"writing-code/#examples","text":"","title":"Examples"},{"location":"writing-code/#check-if-a-badge-is-equipped","text":"% in: A0 = badge ID to check for % out: V0 = 1 if badge equipped, 0 if not #DEF A0, *BadgeID PUSH S0, S1 % Push saved registers to stack LIO S0, 8010F498 % Initialize loop start ADDIU S1, S0, 80 % 0x40 badge slots LOOP S0 = S0:2:S1 LHU V1, 0 (S0) BEQL V1, *BadgeID, .Done ADDIU V0, R0, 1 % Return TRUE ENDLOOP CLEAR V0 % Return FALSE .Done JPOP S0, S1 % Pop saved registers from stack","title":"Check if a badge is equipped"},{"location":"writing-code/#writing-a-script-callable-function","text":"Functions intended to be called by scripts using the Call command must follow certain rules to operate correctly. Your function must return a value from the eCommandResult enum (detailed below). Most functions will return eScriptContinue , indicating the script should resume execution after the function is complete. Return 0 instead if you\u2019d like to block the script and have it call your function every frame until some task is finished or condition is met. You may use the int[4] array at (script_context + 0x70) to store temporary values between repeated calls if you don\u2019t want to modify the script variables. Valid return values: FF eScriptYield Script will stop executing (until next frame) <0 ??? script returns 1 0 eScriptBlock Script will not proceed any further this frame 1 ??? script returns 0 2 eScriptContinue 3 eScriptRepeat Arguments: A0 pointer to the script_context data structure of the caller A1 isInitialCall boolean, true on the first call, false on subsequent ones A2 address of the callee function S0 pointer to the function argument list in the script S1 duplicate of A0","title":"Writing a Script-Callable Function"},{"location":"writing-patch-files/","text":"Writing Patch Files # Introduction # Since the memory of the N64 is limited, sections of the ROM containing assets, scripts, and code are loaded into memory as they are needed. For example, data is loaded whenever the player enters a new map, starts a battle, uses a move, and so on. These chunks of data are referred to as data sections . Each map has its own map data section while battles are grouped together by area (ex: battles from Dry Dry Desert or battles from Koopa Bros Fortress). Each boss usually has their own battle data section. Each player move has its own data section, as do different actions in the overworld. Star Rod rips these data sections from the ROM and recursively scans through them to detect scripts and data structures. Most data structures have been identified and reverse engineered. Star Rod's automated system will find the vast majority of them and write them to text files: mscr for maps and bscr for battles. Much of the game logic is implemented through a custom event and scripting engine, which is available to us as script bytecode . This bytecode is sufficiently high-level for us to create new enemies, setup complex map logic, and make new cutscenes without having to write any (or perhaps just a little) assembly. The scripts are dumped along with all the other data structures in each data section. The dumped data structures can be patched by editing their text in patch files: mpat for map-related data and bpat for battle-related data. These patches are converted from their various text formats to binary and written over the original structures. If the patched structure is larger than the original, it will be moved to a free location in memory and all pointers to it are automatically updated. You can also declare new data structures in your patch files. Since the text formats for structures in source and patch files are identical, you can copy structures from one source file into a patch file. For example, this can be used to copy enemies from one battle section to another or copy NPCs from one map to another. The distinction between map and battle data serves two important purposes. First, the set of \u201clibrary\u201d functions and scripts that are available to call from scripts is different in these two environments. This is because \u201clibrary\u201d or \u201ccommon\u201d data is loaded into and out of memory whenever a battle begins or ends. The list of available library functions and scripts can be found in the database folder. Second, different data structures are used in battles and maps. For example, NPCs are only relevant to map scripts and Actors are only relevant to battle scripts. Keeping track of which functions and data structures are available to which scripts is something Star Rod does automatically. To really understand how these files are structured, you should inspect the dumped sources and study how the game logic is structured. The best way to implement a new feature is often to find a map or battle that already does something similar to what you want and see how the developers did it. For example, the overworld AI for Boo enemies in Pro Mode was created by duplicating and modifying the Ember AI. Basic Patch File Syntax # Patches are written like this: @ $DataTable_80241C00 { 002A0000 002B0010 002C0015 002D0002 } This tells Star Rod to look for a data structure called DataTable_80241C00 and overwrite it with the 16 bytes that appear on the following line. Patches are contained within curly brackets. Let's try something more advanced. We can choose to only overwrite the third value by adding an offset to the start of our patchs: @ $DataTable_80241C00 { [8] 002C0015 } By default, each token in a patch is treated as a hexadecimal 32-bit integer. So the value \u201c1\u201d writes \u201c00000001\u201d. This can be changed by adding a suffix identifying the token as a decimal number (`), and as either a 16-bit short (s) or a 8-bit byte (b). You can use the minus sign for negative numbers in any format. Float values will be treated as IEEE floats, but leading decimal places are not allowed. Here are some examples of numbers: 128 = 00000128 100` = 00000064 12b = 12 12`b = 0C 1FFs = 01FF -10s = FFF0 3.2 = 404CCCCD -2.5 = C0200000 .5 = error More sophisticated patches are available for certain data structures. Function patches expect MIPS assembly code, script patches expect lines of Paper Mario's scripting language, strings expect Star Rod's string markup language, and so on. You can also use constant values defined locally or globally, enumerated values from the database directory, or special expressions like ~Vec3d:LocationMarker that produce specially formatted data or read data from editable map files. Patch Syntax Reference # % comment Single line comment /% ... %/ Multi-line comment. Can begin or end at any point in a line. Everything between these will be replaced with a single space and will not begin a new line. @ $Pointer { .. } Starts a new patch overwriting the data structure at $Pointer . The $ indiciates this is the address of some named data structure. @ $Pointer { [40] ... } Add an offset to the patch location. @ $Pointer { [40] ... [60] ... } Alternate way to create patches with offsets. More than one can be used, but each must start on a new line. @ $Pointer [40]{ [40] ... [60] ... } Set the base offset for a patch. Other patch offsets for this struct will be relative to this value. Hence, the [10] will begin at $Pointer[50] and the [20] will begin at $Pointer[60] . .Constant Local/global constants, enum values from in /database/types/, or struct-specific constant values. *ScriptVariable Special pointers used for both local variables in scripts and global game data. See \u201cScript Variables\u201d for more information. ~Expression Converts the enclosed statement into some complicated binary expression. Used by some scripts to reference data from maps and other source files. #directive Used for imports, creating new structs, renaming them, and more. Directives # #new:StructType $StructName Creates a new struct and immediately begins reading a patch for it. You can add extra patches to the struct just like any other. #import OtherFile.mpat Imports all patches from another patch file in the relevant /import/ directory. For battle scripts, the /enemy/ directory may also be used. You can add patches to imported structs if you need to modify their properties. #import MyFile.bpat FileNamespace The second example shows an import with a qualifying namespace. Structures imported in this way will have names like: $FileNamespace:PointerName . If the imported file has imports of its own, the resulting import will have a nested namespace, ie: $Outer:Inner:OriginalName . #define .Name Value Creates a new constant. The constant may be referenced anywhere in the current script. Global constants must be defined in either a global patch file or an enum file. #alias $ComplicatedStructName $SimpleName Adds another name to reference an existing struct. #delete $StructName Clears the memory associated with an existing struct. Useful if you need to create more room in an existing map or battle section. #reserve 80231000 80238000 Reserves an area of RAM. No new structures will be placed there. You can use it for whatever you like. General Guy uses this area to load each wave of minions. Only one region of RAM may be reserved per patch file. Expressions # ~String: StringName Replaced with the string index assigned to a named custom string (see \u201cEditing Strings\u201d). ~SizeOf: Type Replaced with an int token equal to the size of a struct type, e.g. ~Sizeof:Actor . Only works for structs that have a fixed size, i.e. not Function, Script, etc. ~Index: VariableName Replaced by the index of a variable. Example: ~Index: DojoRank resolves to 1C since DojoRank = *GameByte[01C]. ~Func: FunctionName Used in function structs to identify calls to known engine functions. Function names are read from /database/*.lib ~FX: EffectName Used in script calls to the PlayEffect function, assigning meaningful names to a pair of function arguments. Values are read from /database/types/effects.txt ~Flags: FlagType : FlagValues ~Flags: FlagType : FlagValues : Constant ~Flags: FlagType :: Constant Flag type is a name from a flags file in $database/types/ . Flag values is a series of flag names separated by |. This value can be blank, but must always be present. Constant is just a constant value to OR with the combination of flag values (intended for undocumented flags). The constant field may be omitted. Example: ~Flags:DamageType:NoContact|Fire for a fire-type move that doesn't count as direct contact. ~Short: ConstName Resolves a constant and writes it to the patch as a 16-bit short. ~Byte: ConstName Resolves a constant and writes it to the patch as a 16-bit short. ~Sprite: SpriteName : AnimationName ~Sprite: SpriteName : PaletteName : AnimationName Expands to an NPC sprite animation ID. Names of animations and palettes can be changed using the Sprite Editor. ~RasterFile: Format : Filename ~PaletteFile: Format : Filename Copies the contents of an image or palette file from the $mod/res directory according to a specified image format, e.g. CI-4, IA-8, etc. The filename is relative to $mod/res . Supported formats are: I-4, I-8, IA-4, IA-8, IA-16, CI-4, CI-8, RGBA-16, RGBA-32 ~BinaryFile: Filename Copies the contents of a binary file from the $mod/res directory as a series of byte tokens. The file will not be padded. The filename is relative to $mod/res . Map Expressions # Expressions can be used to reference map object data, like ID values or positions from names given in the map editor. When used in a map patch file (.mpat), these expressions may omit the MapName field when referencing the current map. ~Model: MapName : ModelName ~ModelShort: MapName : ModelName Replaced by the ID (32 or 16 bit) of the first model in the model tree with a given name based on a breadth first traversal. Avoid issues by using unique model names. ~Collider: MapName : ColliderName ~ColliderShort: MapName : ColliderName ~Zone: MapName : ZoneName ~ZoneShort: MapName : ZoneName Identical to Model and ModelShort. ~XXX: MapName : MarkerName Marker location expression with valid values for the location XXX are: Vec2d, Vec2f 2D planar position VecXZd, VecXZf Alternative name for 2D planar position Vec3d, Vec3f 3D position PosXd, PosXf X coordinate value PosYd, PosYf Y coordinate value PosZd, PosZf Z coordinate value Angle, Angled Yaw angle Vec4d, Vec4f 3D position followed by yaw angle In each case, the expression will be replaced by either floating point ( f ) or 32-bit int ( d ) values for the given location. ~Path3d: MapName : MarkerName ~Path3f: MapName : MarkerName Replaced by an array of 3D points in the path assigned to the marker. ~PushGrid: MapName : MarkerName Used by CreatePushBlockGrid to specify a grid for blue pushable blocks. Constant Offsets # You can get a relative address within a struct using an offset, which may either be a number or a constant value: $MyPointer[offset] $MyPointer[.Constant] Functions allow using one of their internal labels as offsets: $MyFunction[.o150] Offsets may also be applied to constants, in which case the value of the constants are added together. You may nest offsets in this way: #define .ConstA 10 #define ConstB 3 .ConstA[.ConstB] % == 13 $MyPointer[.ConstA[.ConstB[2]]] % address of MyPointer + 13 Script Variables # There are a set of special values which are used in scripts to denote variables. If one of these variables is passed to a function, it will usually read the value from that variable instead of the literal value of the argument. Each set of script variables can be understood as an array with a certain scope and for a certain purpose. Name Description Maximum First Value *GameByte[i] Global saved byte. 0x200 F5DE0180 (-170m) *GameFlag[i] Global saved flag. 0x800 F8405B80 (-130m) *ModByte[i] Extra saved byte for mods. 0x1000 --- *ModFlag[i] Extra saved flag for mods. 0x8000 --- *AreaByte[i] Cleared on area change. 0x10 F70F2E80 (-150m) *AreaFlag[i] Cleared on area change. 0x100 F9718880 (-110m) *MapVar[i] Cleared on map change. 0x10 FD050F80 (-50m) *MapFlag[i] Cleared on map change. 0x60 FAA2B580 (-90m) *Fixed[0.3] Fixed point real. Precision = 1/1024 \u00b119531 F24A7A80 (-230m) *Array[i] From allocated script array. varies F4ACD480 (-190m) *FlagArray[i] From allocated script array. varies F37BA780 (-210m) *Var[i] Script variables. 0x10 FE363C80 (-30m) *Flag[i] Script flags. 0x60 FBD3E280 (-70m) Note: Flags are packed into 32-bit words from LSB to MSB, 1F 1E 1D ... 02 01 00 3F 3E 3D ... 22 21 20 etc. Just like with other offsets, the array offsets into variables can either be numeric, e.g. Var[4] , *GameByte[80] , etc; or constant GameByte[.SomeConstant] . Map Variables # const pointer 802DA480 holds address of MapFlags (usually 802DBC70, size = 0xC bytes) const pointer 802DA484 holds address of MapVars (usually 802DBCA8, size = 0x40 bytes) During map transitions, these are cleared by [802C3278] Area Variables # 800DBF70-800DBF90 800DBF90-800DBFA0 The area byte/flag variables are cleared whenever the player leaves the area. They have a limited capacity, so don't overuse them. This is for persistent, but temporary data. For example, an NPC that says different things when you talk to them repeatedly. During area transitions, these are cleared by [80145390] Utility Functions # Functions read from and write to these variables with a set of helper functions, which you must familiarize yourself with. Each takes an argument pointing to the \u201cscript context\u201d -- the data structure holding the state of the script which called the function. For more on that, read section 3.1. Script Bytecode . These functions can be called with a NULL (0) script context, in which case Var[x] and Flag[x] will not be resolvable. Whether variables are treated as integers or floats depends on which set of functions you use. get_variable \u2003\u2003\u2003\u2003 (802C7ABC) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. V0 (return) Integer value of variable. set_variable \u2003\u2003\u2003\u2003 (802C8098) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. A2 New value to set. V0 (return) Previous integer value of variable. get_float_variable \u2003 (802C842C) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. F0 (return) Floating-point value of variable. set_float_variable \u2003 (802C8640) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. A2 New value to set. F0 (return) Previous floating-point value of variable. get_float \u2003\u2003\u2003\u2003\u2003\u2003 (802C4920) A0 *Fixed script variable. If out of range, assumes value is a \u201creasonably-sized\u201d float. F0 Floating point value. get_fixed \u2003\u2003\u2003\u2003\u2003\u2003 (802C496C) F12 Fixed script variable V0 Fixed representation. Not range-checked! Ensure arguments no larger than \u00b119531. set_global_flag \u2003\u2003\u2003 (80145450) sets GlobalFlag[i], accepts either indices or encoded values. returns the old value. get_global_flag \u2003\u2003\u2003 (801454BC) returns GlobalFlag[i], accepts either indices or encoded values. set_global_byte \u2003\u2003\u2003 (80145520) sets GlobalByte[i] at 800DBD70, accepts ONLY indices, returns the old value. get_global_byte \u2003\u2003\u2003 (80145538) returns GlobalByte[i] from 800DBD70, accepts ONLY indices. set_area_byte \u2003\u2003\u2003\u2003 (80145638) sets AreaByte[i] at 800DBF90, accepts ONLY indices, returns the old value. get_area_byte \u2003\u2003\u2003\u2003 (80145650) returns AreaByte[i] from 800DBF90, accepts ONLY indices. set_area_flag \u2003\u2003\u2003\u2003\u2003 (801455A0) sets AreaFlag[i] at 800DBF70, accepts ONLY indices, returns the old value. get_area_flag \u2003\u2003\u2003\u2003\u2003 (801455F0) returns AreaFlag[i] from 800DBF70, accepts ONLY indices. Global Patches # Patches in $mod/global/patches/ are applied directly to the ROM, allowing for global modifications. Modifying Existing Data # @Data XXXX @Function XXXX @Hook XXXX @Script:Global XXXX @Script:Map XXXX @Script:Battle XXXX @Fill XXXX YYYY Fills a region of the ROM between XXX and YYY with whatever pattern is supplied as the patch. The pattern will repeat to fill the region and be truncated if it goes beyond the end. Creating New Global Structs # #new:Data $Name Use this to patch arbitrary data to the ROM. #new:Function $Name Use this to patch a function written in MIPS assembly to the ROM. #new:Script:Global $Name #new:Script:Map $Name #new:Script:Battle $Name Use these to create new scripts using particular function APIs. #reserve XXXX $Name Reserves XXXX bytes in RAM and stores the address in the $Name pointer, which can be referenced elsewhere in global patches. #export:Function $GlobalFunction \u2002 Create a struct as global. #export .NewConstName XXXX \u2003\u2003 Create a constant as global. #export $GlobalPointer \u2003\u2003\u2003\u2003\u2003\u2003\u2003 Make an existing struct global. #export .ExistingConstName \u2003\u2003\u2003\u2003 Make an existing constant global. Export makes things global. It works with both pointers and constants. You can also use #export: instead of #new: as a shorthand for creating global structs. Hint Files # The automatic recursive dumping system is sometimes unable to find all data structures in a data section, and generally unable to give descriptive names to the structures it does find. Fortunately, a hint system allows mod authors to supply hints to the dumping process. Hint files are located in /database/hints/ with names that match the source files they apply to. You\u2019ll find a large variety of default hints there. Within each file, the following hints are supported: Command Description add Identifies a new data structure of a given type. ex: add 80240210 Function name Assign a unique name to a data structure. ex: name 80240210 Function_FadeScreenToBlack size Forces a certain size for a data structure. Rarely needed. ex: size 80240210 800 newline Sets how many 32-bit words should be printed on each line. Default = 8. ex: newline 80240210 6","title":"Writing Patch Files"},{"location":"writing-patch-files/#writing-patch-files","text":"","title":"Writing Patch Files"},{"location":"writing-patch-files/#introduction","text":"Since the memory of the N64 is limited, sections of the ROM containing assets, scripts, and code are loaded into memory as they are needed. For example, data is loaded whenever the player enters a new map, starts a battle, uses a move, and so on. These chunks of data are referred to as data sections . Each map has its own map data section while battles are grouped together by area (ex: battles from Dry Dry Desert or battles from Koopa Bros Fortress). Each boss usually has their own battle data section. Each player move has its own data section, as do different actions in the overworld. Star Rod rips these data sections from the ROM and recursively scans through them to detect scripts and data structures. Most data structures have been identified and reverse engineered. Star Rod's automated system will find the vast majority of them and write them to text files: mscr for maps and bscr for battles. Much of the game logic is implemented through a custom event and scripting engine, which is available to us as script bytecode . This bytecode is sufficiently high-level for us to create new enemies, setup complex map logic, and make new cutscenes without having to write any (or perhaps just a little) assembly. The scripts are dumped along with all the other data structures in each data section. The dumped data structures can be patched by editing their text in patch files: mpat for map-related data and bpat for battle-related data. These patches are converted from their various text formats to binary and written over the original structures. If the patched structure is larger than the original, it will be moved to a free location in memory and all pointers to it are automatically updated. You can also declare new data structures in your patch files. Since the text formats for structures in source and patch files are identical, you can copy structures from one source file into a patch file. For example, this can be used to copy enemies from one battle section to another or copy NPCs from one map to another. The distinction between map and battle data serves two important purposes. First, the set of \u201clibrary\u201d functions and scripts that are available to call from scripts is different in these two environments. This is because \u201clibrary\u201d or \u201ccommon\u201d data is loaded into and out of memory whenever a battle begins or ends. The list of available library functions and scripts can be found in the database folder. Second, different data structures are used in battles and maps. For example, NPCs are only relevant to map scripts and Actors are only relevant to battle scripts. Keeping track of which functions and data structures are available to which scripts is something Star Rod does automatically. To really understand how these files are structured, you should inspect the dumped sources and study how the game logic is structured. The best way to implement a new feature is often to find a map or battle that already does something similar to what you want and see how the developers did it. For example, the overworld AI for Boo enemies in Pro Mode was created by duplicating and modifying the Ember AI.","title":"Introduction"},{"location":"writing-patch-files/#basic-patch-file-syntax","text":"Patches are written like this: @ $DataTable_80241C00 { 002A0000 002B0010 002C0015 002D0002 } This tells Star Rod to look for a data structure called DataTable_80241C00 and overwrite it with the 16 bytes that appear on the following line. Patches are contained within curly brackets. Let's try something more advanced. We can choose to only overwrite the third value by adding an offset to the start of our patchs: @ $DataTable_80241C00 { [8] 002C0015 } By default, each token in a patch is treated as a hexadecimal 32-bit integer. So the value \u201c1\u201d writes \u201c00000001\u201d. This can be changed by adding a suffix identifying the token as a decimal number (`), and as either a 16-bit short (s) or a 8-bit byte (b). You can use the minus sign for negative numbers in any format. Float values will be treated as IEEE floats, but leading decimal places are not allowed. Here are some examples of numbers: 128 = 00000128 100` = 00000064 12b = 12 12`b = 0C 1FFs = 01FF -10s = FFF0 3.2 = 404CCCCD -2.5 = C0200000 .5 = error More sophisticated patches are available for certain data structures. Function patches expect MIPS assembly code, script patches expect lines of Paper Mario's scripting language, strings expect Star Rod's string markup language, and so on. You can also use constant values defined locally or globally, enumerated values from the database directory, or special expressions like ~Vec3d:LocationMarker that produce specially formatted data or read data from editable map files.","title":"Basic Patch File Syntax"},{"location":"writing-patch-files/#patch-syntax-reference","text":"% comment Single line comment /% ... %/ Multi-line comment. Can begin or end at any point in a line. Everything between these will be replaced with a single space and will not begin a new line. @ $Pointer { .. } Starts a new patch overwriting the data structure at $Pointer . The $ indiciates this is the address of some named data structure. @ $Pointer { [40] ... } Add an offset to the patch location. @ $Pointer { [40] ... [60] ... } Alternate way to create patches with offsets. More than one can be used, but each must start on a new line. @ $Pointer [40]{ [40] ... [60] ... } Set the base offset for a patch. Other patch offsets for this struct will be relative to this value. Hence, the [10] will begin at $Pointer[50] and the [20] will begin at $Pointer[60] . .Constant Local/global constants, enum values from in /database/types/, or struct-specific constant values. *ScriptVariable Special pointers used for both local variables in scripts and global game data. See \u201cScript Variables\u201d for more information. ~Expression Converts the enclosed statement into some complicated binary expression. Used by some scripts to reference data from maps and other source files. #directive Used for imports, creating new structs, renaming them, and more.","title":"Patch Syntax Reference"},{"location":"writing-patch-files/#directives","text":"#new:StructType $StructName Creates a new struct and immediately begins reading a patch for it. You can add extra patches to the struct just like any other. #import OtherFile.mpat Imports all patches from another patch file in the relevant /import/ directory. For battle scripts, the /enemy/ directory may also be used. You can add patches to imported structs if you need to modify their properties. #import MyFile.bpat FileNamespace The second example shows an import with a qualifying namespace. Structures imported in this way will have names like: $FileNamespace:PointerName . If the imported file has imports of its own, the resulting import will have a nested namespace, ie: $Outer:Inner:OriginalName . #define .Name Value Creates a new constant. The constant may be referenced anywhere in the current script. Global constants must be defined in either a global patch file or an enum file. #alias $ComplicatedStructName $SimpleName Adds another name to reference an existing struct. #delete $StructName Clears the memory associated with an existing struct. Useful if you need to create more room in an existing map or battle section. #reserve 80231000 80238000 Reserves an area of RAM. No new structures will be placed there. You can use it for whatever you like. General Guy uses this area to load each wave of minions. Only one region of RAM may be reserved per patch file.","title":"Directives"},{"location":"writing-patch-files/#expressions","text":"~String: StringName Replaced with the string index assigned to a named custom string (see \u201cEditing Strings\u201d). ~SizeOf: Type Replaced with an int token equal to the size of a struct type, e.g. ~Sizeof:Actor . Only works for structs that have a fixed size, i.e. not Function, Script, etc. ~Index: VariableName Replaced by the index of a variable. Example: ~Index: DojoRank resolves to 1C since DojoRank = *GameByte[01C]. ~Func: FunctionName Used in function structs to identify calls to known engine functions. Function names are read from /database/*.lib ~FX: EffectName Used in script calls to the PlayEffect function, assigning meaningful names to a pair of function arguments. Values are read from /database/types/effects.txt ~Flags: FlagType : FlagValues ~Flags: FlagType : FlagValues : Constant ~Flags: FlagType :: Constant Flag type is a name from a flags file in $database/types/ . Flag values is a series of flag names separated by |. This value can be blank, but must always be present. Constant is just a constant value to OR with the combination of flag values (intended for undocumented flags). The constant field may be omitted. Example: ~Flags:DamageType:NoContact|Fire for a fire-type move that doesn't count as direct contact. ~Short: ConstName Resolves a constant and writes it to the patch as a 16-bit short. ~Byte: ConstName Resolves a constant and writes it to the patch as a 16-bit short. ~Sprite: SpriteName : AnimationName ~Sprite: SpriteName : PaletteName : AnimationName Expands to an NPC sprite animation ID. Names of animations and palettes can be changed using the Sprite Editor. ~RasterFile: Format : Filename ~PaletteFile: Format : Filename Copies the contents of an image or palette file from the $mod/res directory according to a specified image format, e.g. CI-4, IA-8, etc. The filename is relative to $mod/res . Supported formats are: I-4, I-8, IA-4, IA-8, IA-16, CI-4, CI-8, RGBA-16, RGBA-32 ~BinaryFile: Filename Copies the contents of a binary file from the $mod/res directory as a series of byte tokens. The file will not be padded. The filename is relative to $mod/res .","title":"Expressions"},{"location":"writing-patch-files/#map-expressions","text":"Expressions can be used to reference map object data, like ID values or positions from names given in the map editor. When used in a map patch file (.mpat), these expressions may omit the MapName field when referencing the current map. ~Model: MapName : ModelName ~ModelShort: MapName : ModelName Replaced by the ID (32 or 16 bit) of the first model in the model tree with a given name based on a breadth first traversal. Avoid issues by using unique model names. ~Collider: MapName : ColliderName ~ColliderShort: MapName : ColliderName ~Zone: MapName : ZoneName ~ZoneShort: MapName : ZoneName Identical to Model and ModelShort. ~XXX: MapName : MarkerName Marker location expression with valid values for the location XXX are: Vec2d, Vec2f 2D planar position VecXZd, VecXZf Alternative name for 2D planar position Vec3d, Vec3f 3D position PosXd, PosXf X coordinate value PosYd, PosYf Y coordinate value PosZd, PosZf Z coordinate value Angle, Angled Yaw angle Vec4d, Vec4f 3D position followed by yaw angle In each case, the expression will be replaced by either floating point ( f ) or 32-bit int ( d ) values for the given location. ~Path3d: MapName : MarkerName ~Path3f: MapName : MarkerName Replaced by an array of 3D points in the path assigned to the marker. ~PushGrid: MapName : MarkerName Used by CreatePushBlockGrid to specify a grid for blue pushable blocks.","title":"Map Expressions"},{"location":"writing-patch-files/#constant-offsets","text":"You can get a relative address within a struct using an offset, which may either be a number or a constant value: $MyPointer[offset] $MyPointer[.Constant] Functions allow using one of their internal labels as offsets: $MyFunction[.o150] Offsets may also be applied to constants, in which case the value of the constants are added together. You may nest offsets in this way: #define .ConstA 10 #define ConstB 3 .ConstA[.ConstB] % == 13 $MyPointer[.ConstA[.ConstB[2]]] % address of MyPointer + 13","title":"Constant Offsets"},{"location":"writing-patch-files/#script-variables","text":"There are a set of special values which are used in scripts to denote variables. If one of these variables is passed to a function, it will usually read the value from that variable instead of the literal value of the argument. Each set of script variables can be understood as an array with a certain scope and for a certain purpose. Name Description Maximum First Value *GameByte[i] Global saved byte. 0x200 F5DE0180 (-170m) *GameFlag[i] Global saved flag. 0x800 F8405B80 (-130m) *ModByte[i] Extra saved byte for mods. 0x1000 --- *ModFlag[i] Extra saved flag for mods. 0x8000 --- *AreaByte[i] Cleared on area change. 0x10 F70F2E80 (-150m) *AreaFlag[i] Cleared on area change. 0x100 F9718880 (-110m) *MapVar[i] Cleared on map change. 0x10 FD050F80 (-50m) *MapFlag[i] Cleared on map change. 0x60 FAA2B580 (-90m) *Fixed[0.3] Fixed point real. Precision = 1/1024 \u00b119531 F24A7A80 (-230m) *Array[i] From allocated script array. varies F4ACD480 (-190m) *FlagArray[i] From allocated script array. varies F37BA780 (-210m) *Var[i] Script variables. 0x10 FE363C80 (-30m) *Flag[i] Script flags. 0x60 FBD3E280 (-70m) Note: Flags are packed into 32-bit words from LSB to MSB, 1F 1E 1D ... 02 01 00 3F 3E 3D ... 22 21 20 etc. Just like with other offsets, the array offsets into variables can either be numeric, e.g. Var[4] , *GameByte[80] , etc; or constant GameByte[.SomeConstant] .","title":"Script Variables"},{"location":"writing-patch-files/#map-variables","text":"const pointer 802DA480 holds address of MapFlags (usually 802DBC70, size = 0xC bytes) const pointer 802DA484 holds address of MapVars (usually 802DBCA8, size = 0x40 bytes) During map transitions, these are cleared by [802C3278]","title":"Map Variables"},{"location":"writing-patch-files/#area-variables","text":"800DBF70-800DBF90 800DBF90-800DBFA0 The area byte/flag variables are cleared whenever the player leaves the area. They have a limited capacity, so don't overuse them. This is for persistent, but temporary data. For example, an NPC that says different things when you talk to them repeatedly. During area transitions, these are cleared by [80145390]","title":"Area Variables"},{"location":"writing-patch-files/#utility-functions","text":"Functions read from and write to these variables with a set of helper functions, which you must familiarize yourself with. Each takes an argument pointing to the \u201cscript context\u201d -- the data structure holding the state of the script which called the function. For more on that, read section 3.1. Script Bytecode . These functions can be called with a NULL (0) script context, in which case Var[x] and Flag[x] will not be resolvable. Whether variables are treated as integers or floats depends on which set of functions you use. get_variable \u2003\u2003\u2003\u2003 (802C7ABC) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. V0 (return) Integer value of variable. set_variable \u2003\u2003\u2003\u2003 (802C8098) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. A2 New value to set. V0 (return) Previous integer value of variable. get_float_variable \u2003 (802C842C) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. F0 (return) Floating-point value of variable. set_float_variable \u2003 (802C8640) A0 Script context pointer. A1 \u201cVariable\u201d to resolve. Could be constant or a script variable value like FE363C80. A2 New value to set. F0 (return) Previous floating-point value of variable. get_float \u2003\u2003\u2003\u2003\u2003\u2003 (802C4920) A0 *Fixed script variable. If out of range, assumes value is a \u201creasonably-sized\u201d float. F0 Floating point value. get_fixed \u2003\u2003\u2003\u2003\u2003\u2003 (802C496C) F12 Fixed script variable V0 Fixed representation. Not range-checked! Ensure arguments no larger than \u00b119531. set_global_flag \u2003\u2003\u2003 (80145450) sets GlobalFlag[i], accepts either indices or encoded values. returns the old value. get_global_flag \u2003\u2003\u2003 (801454BC) returns GlobalFlag[i], accepts either indices or encoded values. set_global_byte \u2003\u2003\u2003 (80145520) sets GlobalByte[i] at 800DBD70, accepts ONLY indices, returns the old value. get_global_byte \u2003\u2003\u2003 (80145538) returns GlobalByte[i] from 800DBD70, accepts ONLY indices. set_area_byte \u2003\u2003\u2003\u2003 (80145638) sets AreaByte[i] at 800DBF90, accepts ONLY indices, returns the old value. get_area_byte \u2003\u2003\u2003\u2003 (80145650) returns AreaByte[i] from 800DBF90, accepts ONLY indices. set_area_flag \u2003\u2003\u2003\u2003\u2003 (801455A0) sets AreaFlag[i] at 800DBF70, accepts ONLY indices, returns the old value. get_area_flag \u2003\u2003\u2003\u2003\u2003 (801455F0) returns AreaFlag[i] from 800DBF70, accepts ONLY indices.","title":"Utility Functions"},{"location":"writing-patch-files/#global-patches","text":"Patches in $mod/global/patches/ are applied directly to the ROM, allowing for global modifications.","title":"Global Patches"},{"location":"writing-patch-files/#modifying-existing-data","text":"@Data XXXX @Function XXXX @Hook XXXX @Script:Global XXXX @Script:Map XXXX @Script:Battle XXXX @Fill XXXX YYYY Fills a region of the ROM between XXX and YYY with whatever pattern is supplied as the patch. The pattern will repeat to fill the region and be truncated if it goes beyond the end.","title":"Modifying Existing Data"},{"location":"writing-patch-files/#creating-new-global-structs","text":"#new:Data $Name Use this to patch arbitrary data to the ROM. #new:Function $Name Use this to patch a function written in MIPS assembly to the ROM. #new:Script:Global $Name #new:Script:Map $Name #new:Script:Battle $Name Use these to create new scripts using particular function APIs. #reserve XXXX $Name Reserves XXXX bytes in RAM and stores the address in the $Name pointer, which can be referenced elsewhere in global patches. #export:Function $GlobalFunction \u2002 Create a struct as global. #export .NewConstName XXXX \u2003\u2003 Create a constant as global. #export $GlobalPointer \u2003\u2003\u2003\u2003\u2003\u2003\u2003 Make an existing struct global. #export .ExistingConstName \u2003\u2003\u2003\u2003 Make an existing constant global. Export makes things global. It works with both pointers and constants. You can also use #export: instead of #new: as a shorthand for creating global structs.","title":"Creating New Global Structs"},{"location":"writing-patch-files/#hint-files","text":"The automatic recursive dumping system is sometimes unable to find all data structures in a data section, and generally unable to give descriptive names to the structures it does find. Fortunately, a hint system allows mod authors to supply hints to the dumping process. Hint files are located in /database/hints/ with names that match the source files they apply to. You\u2019ll find a large variety of default hints there. Within each file, the following hints are supported: Command Description add Identifies a new data structure of a given type. ex: add 80240210 Function name Assign a unique name to a data structure. ex: name 80240210 Function_FadeScreenToBlack size Forces a certain size for a data structure. Rarely needed. ex: size 80240210 800 newline Sets how many 32-bit words should be printed on each line. Default = 8. ex: newline 80240210 6","title":"Hint Files"},{"location":"writing-scripts/","text":"Writing Scripts # Script Bytecode # Paper Mario uses a custom scripting language to implement most of its high-level game logic. These scripts are compiled into bytecode that is read by an interpreter at runtime. They often call functions to execute particular tasks like PlaySound() or RemoveActor() . This is quite fortunate for the modding community, as it allows for easy higher-level modifications. It is easy to add, for example, new enemy attacks. Internally, each script has a script context , a data structure that manages the state of the script, stores its variable values, etc. A new script context is created every time a new script is run and the context is deleted when the script is finished executing. Inline Script Expressions # The value of script variables can be assigned with mathematical expressions like this: Set *Var[0] = *Var[2] + *Var[3] - 10` These are automatically compiled into basic bytecode commands and optimized for space. You should use these wherever possible to maintain reliability. Use Set and SetF to distinguish between values which should be handled as floats or integers.","title":"Writing Scripts"},{"location":"writing-scripts/#writing-scripts","text":"","title":"Writing Scripts"},{"location":"writing-scripts/#script-bytecode","text":"Paper Mario uses a custom scripting language to implement most of its high-level game logic. These scripts are compiled into bytecode that is read by an interpreter at runtime. They often call functions to execute particular tasks like PlaySound() or RemoveActor() . This is quite fortunate for the modding community, as it allows for easy higher-level modifications. It is easy to add, for example, new enemy attacks. Internally, each script has a script context , a data structure that manages the state of the script, stores its variable values, etc. A new script context is created every time a new script is run and the context is deleted when the script is finished executing.","title":"Script Bytecode"},{"location":"writing-scripts/#inline-script-expressions","text":"The value of script variables can be assigned with mathematical expressions like this: Set *Var[0] = *Var[2] + *Var[3] - 10` These are automatically compiled into basic bytecode commands and optimized for space. You should use these wherever possible to maintain reliability. Use Set and SetF to distinguish between values which should be handled as floats or integers.","title":"Inline Script Expressions"}]}